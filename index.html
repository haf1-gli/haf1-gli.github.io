<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Funy Tank Game</title> <!-- Changed Title -->
    <style>
        /* Basic reset */
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; color: #fff; overflow: hidden; background-color: #333; }
        canvas { display: block; }
        button { cursor: pointer; padding: 10px 20px; font-size: 1rem; border-radius: 5px; border: none; margin: 5px; }
        input[type="text"], select { padding: 10px; font-size: 1rem; border-radius: 5px; border: 1px solid #ccc; margin: 5px; }

        /* --- UI Screens --- */
        .ui-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: none; /* Hidden by default */ flex-direction: column; justify-content: center; align-items: center; background-color: rgba(0, 0, 0, 0.7); z-index: 110; color: #fff; text-align: center; padding: 20px; box-sizing: border-box; }
        .ui-screen.active { display: flex; } /* Show active screen */

        /* Main Menu */
        #main-menu h1 { font-size: 3rem; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); margin-bottom: 30px; }
        #main-menu .input-group { margin-bottom: 15px; }
        #main-menu label { margin-right: 10px; }
        #main-menu .button-group { margin-top: 20px; }

        /* Mode Select */
        #mode-select h2 { margin-bottom: 20px; }
        #mode-select button { display: block; width: 200px; margin-bottom: 10px; }

        /* Code Sharing Screens */
        #share-offer, #get-answer, #get-offer, #share-answer { background-color: rgba(0, 0, 0, 0.85); }
        .code-container { background-color: #222; padding: 15px; border-radius: 5px; margin: 15px 0; word-break: break-all; font-family: monospace; font-size: 0.9rem; max-width: 80%; text-align: left; }
        /* --- FIX: Allow pointer events for text areas using IDs --- */
        #answer-code-input, #offer-code-input {
            width: 100%;
            min-height: 80px;
            margin-bottom: 10px;
            box-sizing: border-box;
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            pointer-events: auto; /* Allow clicks */
            z-index: 1; /* Ensure it's above the container's pseudo-elements if any */
        }
        .copy-button { margin-left: 10px; }

        /* Loading Screen */
        #loading-screen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: #000; color: #fff; display: none; /* Hidden initially */ justify-content: center; align-items: center; font-size: 2rem; z-index: 100; transition: opacity 1s ease; pointer-events: none; }
        #loading-screen.active { display: flex; } /* Show when active */
        #loading-screen.transparent { background-color: rgba(0, 0, 0, 0.7); }
        #loading-screen .attributions { position: absolute; bottom: 10px; left: 10px; font-size: 10px; color: #aaa; line-height: 1.4; }
        #loading-screen .attributions a { color: #ccc; }
        #loading-text { margin-bottom: 50px; /* Space for attributions */ }


        /* --- Game UI --- */
        #game-ui { position: absolute; bottom: 10px; left: 10px; z-index: 98; pointer-events: none; display: flex; flex-direction: column; align-items: flex-start; }
        #action-instructions { color: #fff; font-size: 14px; margin-bottom: 5px; text-shadow: 1px 1px 2px rgba(0,0,0,0.7); min-height: 1.2em; }
        .bar-container { width: 200px; background-color: #333; border-radius: 4px; overflow: hidden; margin-bottom: 5px; }
        #reload-bar-container { height: 8px; }
        #health-bar-container { height: 15px; }
        .bar-fill { height: 100%; transition: width 0.1s linear; border-radius: 4px; }
        #health-bar-fill { background-color: #00ff00; width: 100%; }
        #reload-bar-fill { background-color: #cccccc; width: 100%; }

        /* Score Display */
        .score-display { position: absolute; top: 10px; z-index: 98; font-size: 1.5rem; text-shadow: 1px 1px 3px rgba(0,0,0,0.7); }
        #score-p1 { left: 10px; }
        #score-p2 { right: 10px; }

        /* Vignette, Crosshair, Exit Instructions */
        #vignette { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: radial-gradient(ellipse at center, rgba(0,0,0,0) 50%, rgba(0,0,0,0.9) 100%); pointer-events: none; z-index: 99; opacity: 0; transition: opacity 0.5s ease; }
        #vignette.active { opacity: 1; }
        #crosshair { position: fixed; top: 50%; left: 50%; width: 10px; height: 10px; border: 1px solid rgba(255, 255, 255, 0.7); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 100; opacity: 0; transition: opacity 0.5s ease; }
        #crosshair.active { opacity: 1; }
        #precision-exit-instructions { position: absolute; top: 10px; left: 10px; color: #fff; background-color: rgba(0, 0, 0, 0.5); padding: 5px 10px; border-radius: 4px; font-size: 0.9rem; z-index: 102; opacity: 0; transition: opacity 0.3s ease; pointer-events: none; }
        #precision-exit-instructions.active { opacity: 1; }

        /* Initial Instructions */
        #initial-instructions { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #fff; background-color: rgba(0, 0, 0, 0.7); padding: 15px 25px; border-radius: 8px; font-size: 1.5rem; text-align: center; z-index: 102; opacity: 1; transition: opacity 0.5s ease; pointer-events: none; }
        #initial-instructions.hidden { opacity: 0; }

        /* Round Over Message */
        #round-over-message { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%) scale(0.1); font-size: 2.5rem; text-shadow: 2px 2px 5px rgba(0,0,0,0.8); z-index: 105; opacity: 0; transition: transform 0.5s ease-out, opacity 0.5s ease-out; pointer-events: none; white-space: nowrap; }
        #round-over-message.active { transform: translate(-50%, -50%) scale(1); opacity: 1; }

        /* Cinematic Bars */
        .cinematic-bar { position: absolute; left: 0; width: 100%; height: 0%; background-color: #000; z-index: 120; transition: height 0.8s ease-in-out; }
        #cinematic-top { top: 0; }
        #cinematic-bottom { bottom: 0; }
        .cinematic-bar.active { height: 10%; }
        .cinematic-bar.full { height: 50%; }

        /* Score Reveal */
        #score-reveal { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 121; font-size: 5rem; font-weight: bold; text-shadow: 2px 2px 5px rgba(0,0,0,0.8); opacity: 0; transition: opacity 0.5s ease 0.8s; }
        #score-reveal.active { opacity: 1; }
        #score-reveal-p1 { display: inline-block; }
        #score-reveal-p2 { display: inline-block; }
        #score-reveal-separator { margin: 0 10px; display: inline-block; }
        .loser-score { color: #888 !important; font-size: 4rem; }

    </style>
</head>
<body>
    <!-- UI Screens -->
    <div id="main-menu" class="ui-screen active">
        <h1>Funy Tank Game</h1>
        <div class="input-group">
            <label for="username">Username:</label>
            <input type="text" id="username" pattern="[a-zA-Z0-9]+" required placeholder="Alphanumeric, no spaces">
        </div>
        <div class="input-group">
            <label for="color-select">UI Color:</label> <!-- Changed label -->
            <select id="color-select">
                <option value="#ff0000">Red</option>
                <option value="#0000ff">Blue</option>
                <option value="#ffff00">Yellow</option>
                <option value="#ff69b4">Pink</option>
                <option value="#ff00ff">Magenta</option>
                <option value="#ffffff">White</option>
                <option value="#000000">Black</option>
            </select>
        </div>
        <div class="button-group">
            <button id="host-button" disabled>Host Game</button>
            <button id="join-button" disabled>Join Game</button>
        </div>
    </div>

    <div id="mode-select" class="ui-screen">
        <h2>Select Game Mode</h2>
        <button data-mode="bo3">Best of 3 Rounds</button>
        <button data-mode="bo5">Best of 5 Rounds</button>
        <button data-mode="infinite">Infinite Rounds</button>
    </div>

    <div id="get-answer" class="ui-screen"> <!-- Host shares offer, waits for answer -->
        <h2>Waiting for Player...</h2>
        <p>Copy this Offer Code and send it to your friend:</p>
        <div id="offer-code-display" class="code-container">Generating...</div>
         <button id="copy-offer-button" class="copy-button">Copy Offer</button>
        <p>Enter the Answer Code from your friend below:</p>
        <textarea id="answer-code-input" placeholder="Paste Answer Code here"></textarea>
        <button id="submit-answer-button">Connect</button>
        <button id="cancel-host-button">Cancel</button>
    </div>

    <div id="get-offer" class="ui-screen"> <!-- Joiner pastes offer -->
        <h2>Join Game</h2>
        <p>Enter the Offer Code from the host:</p>
        <textarea id="offer-code-input" placeholder="Paste Offer Code here"></textarea>
        <button id="submit-offer-button">Submit Offer</button>
        <button id="cancel-join-button">Cancel</button>
    </div>

    <div id="share-answer" class="ui-screen"> <!-- Joiner shares answer -->
        <h2>Share Answer Code</h2>
        <p>Copy this Answer Code and send it back to the host:</p>
        <div id="answer-code" class="code-container">Generating...</div>
        <button id="copy-answer-button" class="copy-button">Copy Answer</button>
        <p>Waiting for host to connect...</p>
         <button id="cancel-join-button-2">Cancel</button>
    </div>

    <div id="connecting" class="ui-screen">
        <h2>Connecting...</h2>
    </div>

    <!-- Loading Screen Overlay -->
    <div id="loading-screen">
        <p id="loading-text">Loading Assets...</p>
        <div class="attributions">
             <p>"Giant Low Poly Tree" (<a href="https://skfb.ly/6tuTE" target="_blank">https://skfb.ly/6tuTE</a>) by Sahir Virmani is licensed under Creative Commons Attribution (<a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>).</p>
             <p>"LOW POLY - INDUSTRIAL WAREHOUSE" (<a href="https://skfb.ly/osUIT" target="_blank">https://skfb.ly/osUIT</a>) by Colin.Greenall is licensed under Creative Commons Attribution (<a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>).</p>
             <p>"Concrete Armored Barrier" (<a href="https://skfb.ly/oFtJX" target="_blank">https://skfb.ly/oFtJX</a>) by TampaJoey is licensed under Creative Commons Attribution (<a href="http://creativecommons.org/licenses/by/4.0/" target="_blank">CC BY 4.0</a>).</p>
             <p>Explosion Sprite Sheet: "Explosion animations" by elnineo via <a href="https://opengameart.org/content/explosion-animations" target="_blank">opengameart.org</a> (CC0?)</p>
             <p>Explosion Sound: Sound Effect by <a href="https://pixabay.com/users/ahmed_abdulaal-49290858/?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=312361" target="_blank">Ahmed Abdulaal</a> from <a href="https://pixabay.com/sound-effects//?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=312361" target="_blank">Pixabay</a> (Pixabay Content License)</p>
             <p>Win Sound: Sound Effect from <a href="https://pixabay.com/sound-effects/?utm_source=link-attribution&utm_medium=referral&utm_campaign=music&utm_content=100346" target="_blank">Pixabay</a></p>
        </div>
    </div>

    <!-- Game UI -->
    <div id="game-ui">
        <div id="action-instructions">E to shoot</div>
        <div id="reload-bar-container" class="bar-container"> <div id="reload-bar-fill" class="bar-fill"></div> </div>
        <div id="health-bar-container" class="bar-container"> <div id="health-bar-fill" class="bar-fill"></div> </div>
    </div>
    <div id="vignette"></div> <div id="crosshair"></div>
    <div id="score-p1" class="score-display">P1: 0</div> <div id="score-p2" class="score-display">P2: 0</div>
    <div id="round-over-message">Round Over!</div>
    <div id="initial-instructions"> WASD = Drive | Mouse = Aim | Right Click = Precision Mode </div>
    <div id="precision-exit-instructions"> Esc to exit precision mode </div>
    <div id="cinematic-top" class="cinematic-bar"></div> <div id="cinematic-bottom" class="cinematic-bar"></div>
    <div id="score-reveal">
        <span id="score-reveal-p1">0</span>
        <span id="score-reveal-separator">:</span>
        <span id="score-reveal-p2">0</span>
    </div>

    <!-- Import map & PeerJS -->
    <script src="https://cdn.jsdelivr.net/npm/simple-peer@9.11.1/simplepeer.min.js"></script>
    <script type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.164.1/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.164.1/examples/jsm/" } } </script>

    <!-- Main Logic -->
    <script type="module">
        import * as THREE from 'three';
        import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
        import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- Game States & Multiplayer Vars ---
        const GameState = { MENU: 'MENU', HOSTING_MODE_SELECT: 'HOSTING_MODE_SELECT', HOSTING_GET_ANSWER: 'HOSTING_GET_ANSWER', JOINING_GET_OFFER: 'JOINING_GET_OFFER', JOINING_SHARE_ANSWER: 'JOINING_SHARE_ANSWER', CONNECTING: 'CONNECTING', GAME_LOADING: 'GAME_LOADING', GAME_PLAYING: 'GAME_PLAYING', ROUND_OVER: 'ROUND_OVER', CUTSCENE_START: 'CUTSCENE_START', CUTSCENE_SCORE: 'CUTSCENE_SCORE', CUTSCENE_OUTCOME: 'CUTSCENE_OUTCOME', CUTSCENE_END: 'CUTSCENE_END' };
        let currentGameState = GameState.MENU;
        let selectedGameMode = 'infinite'; let maxRounds = Infinity; let currentRound = 1;
        let peer = null; let localUsername = ''; let localColor = '#ff0000'; let remoteUsername = 'Player 2'; let remoteColor = '#0000ff';
        let localScore = 0; let remoteScore = 0; let localPlayerId = 'p1'; let remotePlayerId = 'p2'; let isHost = false;
        let hostReady = false; let joinerReady = false; // Readiness flags
        let mapData = null; // To store map config

        // --- Three.js Variables ---
        let camera, scene, renderer; let clock; let ground;
        let localTank, remoteTank;
        let tankHeadPivotLocal, tankTurretPivotLocal, tankHeadPivotRemote, tankTurretPivotRemote;
        // Keep refs to specific models if needed for direct manipulation (like turret)
        let tankTurretModelLocal, tankTurretModelRemote; // Store turret models specifically
        let pivotMarker, turretPivotMarker; // For debug
        let raycaster, collisionRaycaster, bulletRaycaster;
        let mainLoadingManager;
        let muzzleDebugArrow, trajectoryLine;
        let explosionSpriteSheet, explosionSoundBuffer, winSoundBuffer;
        let audioListener;
        let woodParticleMaterial, woodParticleGeometry;

        // --- State ---
        let isAimLocked = false; let isPrecisionAiming = false; let isPointerLocked = false; let isReloading = false; let isReloaded = true; let reloadProgress = 1.0;
        let firstInputReceived = false; let isFollowingBullet = false; let followBulletTimer = 0; const followBulletDuration = 0.5;
        let cameraShakeIntensity = 0.0; let controlsEnabled = true;

        // --- Debug ---
        let isDebugMode = false; const debugHelpers = new THREE.Group();

        // --- Scene Objects ---
        const collidables = []; const collidableBoxes = []; const trees = []; const barriers = [];
        const bullets = []; const explosions = []; const particles = [];
        // Removed remoteBullets - handle spawning locally based on messages

        // --- Movement State (Intent) ---
        let moveForward = false; let moveBackward = false; let moveLeft = false; let moveRight = false;

        // --- Movement Physics & Player Stats (Local) ---
        const localTankState = { position: new THREE.Vector3(0, 30, 0), velocity: new THREE.Vector3(), angularVelocity: 0.0, yaw: 0.0, headYaw: 0.0, turretPitch: 0.0, health: 100, isAlive: true };
        const remoteTankState = { position: new THREE.Vector3(0, 30, 0), velocity: new THREE.Vector3(), angularVelocity: 0.0, yaw: 0.0, headYaw: 0.0, turretPitch: 0.0, health: 100, isAlive: true, targetPosition: new THREE.Vector3(0, 30, 0), targetYaw: 0.0, targetHeadYaw: 0.0, targetTurretPitch: 0.0, lastUpdateTimestamp: 0 };
        const playerAcceleration = 60.0; const playerDamping = 10.0; const playerTurnAcceleration = 15.0; const playerTurnDamping = 20.0;
        const headTurnSpeed = 1.5; const turretPitchSpeed = 2.0;
        const maxPlayerHealth = 100; const reloadTime = 3.0;

        // --- Shooting ---
        let canShoot = true; const shootCooldown = 0.2; let bulletSpeed = 197.00; let bulletGravityStrength = 50.00;
        const explosionDuration = 0.8; const explosionSize = 20.0; const explosionBlastRadius = 10.0; const explosionMaxDamage = 50.0;
        let muzzlePosition = new THREE.Vector3(20.00, -18.60, 5.30); let muzzleRotation = new THREE.Euler(0, 91 * (Math.PI / 180), 0);

        // --- Explosion Sprite Sheet Config ---
        const explosionRows = 8; const explosionCols = 8; const explosionTotalFrames = 64;

        // --- Camera Orbit & Aiming ---
        let isMouseDown = false; let previousMouseX = 0; let previousMouseY = 0; let cameraYaw = 0; let cameraPitch = 0.4;
        let mouseX = window.innerWidth / 2; let mouseY = window.innerHeight / 2;
        const cameraDistance = 15.0; const cameraLookAtOffset = new THREE.Vector3(0, 2, 0); const cameraPitchMin = 0.1; const cameraPitchMax = 1.4;

        // --- Precision Aim Camera ---
        const defaultFov = 75; const precisionFovBase = 20; let precisionZoomLevel = 0;
        const precisionFovMin = 15; const precisionFovMax = 30; const precisionAimSensitivity = 0.001;

        // --- Cutscene ---
        let cutsceneTimer = 0; let scoreRevealP1 = 0; let scoreRevealP2 = 0; let scoreRevealStep = 0; let winSound;

        // --- Model Config ---
        const bodyModelScale = 0.1; const bodyModelPositionOffset = new THREE.Vector3(-2, -1, -1); const bodyModelRotationOffset = new THREE.Euler(-Math.PI / 2, 0, -Math.PI / 2);
        const headModelScale = 0.1; const headModelPositionOffset = new THREE.Vector3(1.90, 0.00, -7.20); const headModelRotationOffset = new THREE.Euler(-Math.PI / 2, 0, -Math.PI / 2);
        const turretModelScale = 1; const turretModelPosition = new THREE.Vector3(-32.60, 0.00, 1.00); const turretModelRotation = new THREE.Euler(0, 0, 0);
        const tankHeadPivotPosition = new THREE.Vector3(-0.20, 0.30, 1.30); const turretPivotPosition = new THREE.Vector3(67.10, 0.00, 0.00);

        // --- Decoration Config ---
        const MIN_WAREHOUSES = 6; const MAX_WAREHOUSES = 8; const warehouseScale = 120.00; const warehouseYOffset = 0.8;
        const MIN_TREES = 15; const MAX_TREES = 20; const treeScale = 0.80; const treeYOffset = 0.00; const treeScaleVariation = 0.20;
        const MIN_BARRIERS = 15; const MAX_BARRIERS = 25; const barrierScale = 2.20; const barrierYOffset = -0.40;
        const PLAYER_SPAWN_RADIUS = 5.0; const SPAWN_AREA = 450; const PLAYER_MIN_SEPARATION = 50;

        // --- Helper Vectors ---
        const playerForward = new THREE.Vector3(); const groundNormal = new THREE.Vector3(); const upVector = new THREE.Vector3(0, 1, 0);
        const tiltQuaternion = new THREE.Quaternion(); const yawQuaternion = new THREE.Quaternion(); const finalQuaternion = new THREE.Quaternion();
        const cameraOffset = new THREE.Vector3(); const worldOffset = new THREE.Vector3(); const lookAtTarget = new THREE.Vector3(); const rayOrigin = new THREE.Vector3();
        const spawnCheckPos = new THREE.Vector2(); const collidableCheckPos = new THREE.Vector2(); const collidableBoxSize = new THREE.Vector3();
        const bulletGeometry = new THREE.SphereGeometry(0.2, 8, 8); const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const explosionGeometry = new THREE.PlaneGeometry(1, 1); let explosionMaterial;
        const muzzleDirection = new THREE.Vector3(); const muzzleWorldPos = new THREE.Vector3(); const muzzleWorldQuat = new THREE.Quaternion(); const muzzleOffsetQuat = new THREE.Quaternion();
        const trajectoryPoints = []; const trajectoryVelocity = new THREE.Vector3();
        const precisionCamPos = new THREE.Vector3(); const precisionCamQuat = new THREE.Quaternion(); const precisionCamTargetQuat = new THREE.Quaternion(); const thirdPersonCamPos = new THREE.Vector3();
        const followBulletStartPos = new THREE.Vector3(); const followBulletDirection = new THREE.Vector3(); const followBulletLookAt = new THREE.Vector3();
        const shakeOffset = new THREE.Vector3();
        const particleGravity = 9.8; const particleLifespan = 3.0;

        // --- UI Element References ---
        let healthBarFill, reloadBarFill, vignetteElement, crosshairElement, actionInstructionsElement, initialInstructionsElement, precisionExitInstructionsElement;
        let scoreP1Element, scoreP2Element, roundOverMsgElement;
        let cinematicTopBar, cinematicBottomBar, scoreRevealElement, scoreRevealP1Span, scoreRevealP2Span, scoreRevealSeparatorSpan;
        let loadingTextElement;

        // --- Input Handlers ---
        const onKeyDown = (event) => { hideInitialInstructions(); if (!controlsEnabled) return; switch (event.code) { case 'KeyW': moveForward = true; break; case 'KeyA': moveLeft = true; break; case 'KeyS': moveBackward = true; break; case 'KeyD': moveRight = true; break; case 'KeyE': shoot(); break; case 'KeyR': if (!isReloading && !isReloaded) { isReloading = true; updateActionInstructions(); } break; case 'KeyQ': isAimLocked = !isAimLocked; break; case 'KeyI': isDebugMode = !isDebugMode; debugHelpers.visible = isDebugMode; if(localTank?.userData.headPivotMarker) localTank.userData.headPivotMarker.visible = isDebugMode; if(localTank?.userData.turretPivotMarker) localTank.userData.turretPivotMarker.visible = isDebugMode; if(remoteTank?.userData.headPivotMarker) remoteTank.userData.headPivotMarker.visible = isDebugMode; if(remoteTank?.userData.turretPivotMarker) remoteTank.userData.turretPivotMarker.visible = isDebugMode; break; } };
        const onKeyUp = (event) => { if (!controlsEnabled) return; switch (event.code) { case 'KeyW': moveForward = false; break; case 'KeyA': moveLeft = false; break; case 'KeyS': moveBackward = false; break; case 'KeyD': moveRight = false; break; case 'KeyR': isReloading = false; updateActionInstructions(); break; } };
        const onMouseDown = (event) => { hideInitialInstructions(); if (!controlsEnabled && !isPrecisionAiming) return; if (event.button === 0) { isMouseDown = true; previousMouseX = event.clientX; previousMouseY = event.clientY; } };
        const onMouseUp = (event) => { if (event.button === 0) { isMouseDown = false; } };
        const onMouseMove = (event) => { hideInitialInstructions(); mouseX = event.clientX; mouseY = event.clientY; if (isPrecisionAiming && isPointerLocked) { cameraYaw -= event.movementX * precisionAimSensitivity; cameraPitch += event.movementY * precisionAimSensitivity; cameraPitch = THREE.MathUtils.clamp(cameraPitch, cameraPitchMin, cameraPitchMax); } else if (isMouseDown && !isPrecisionAiming && controlsEnabled) { const deltaX = event.clientX - previousMouseX; const deltaY = event.clientY - previousMouseY; cameraYaw -= deltaX * 0.005; cameraPitch += deltaY * 0.005; cameraPitch = THREE.MathUtils.clamp(cameraPitch, cameraPitchMin, cameraPitchMax); previousMouseX = event.clientX; previousMouseY = event.clientY; } };
        const onContextMenu = (event) => { hideInitialInstructions(); event.preventDefault(); if (controlsEnabled) togglePrecisionAim(); };
        const onMouseWheel = (event) => { hideInitialInstructions(); if (isPrecisionAiming && controlsEnabled) { precisionZoomLevel += event.deltaY * -0.001; precisionZoomLevel = THREE.MathUtils.clamp(precisionZoomLevel, 0, 1); } };
        const onPointerLockChange = () => { isPointerLocked = document.pointerLockElement === renderer.domElement; if (!isPointerLocked && isPrecisionAiming) { isPrecisionAiming = false; vignetteElement.classList.remove('active'); crosshairElement.classList.remove('active'); precisionExitInstructionsElement.classList.remove('active'); } };
        const onPointerLockError = () => { console.error('PointerLock Error'); isPrecisionAiming = false; vignetteElement.classList.remove('active'); crosshairElement.classList.remove('active'); precisionExitInstructionsElement.classList.remove('active'); };
        const onWindowResize = () => { if(camera && renderer) { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); } };


        // --- Initialize ---
        setupMainMenu(); // Setup menu event listeners


        // --- State Management ---
        function setGameState(newState) {
            console.log(`Changing state from ${currentGameState} to ${newState}`);
            currentGameState = newState;
            document.querySelectorAll('.ui-screen').forEach(el => el.classList.remove('active'));
            const loadingScreen = document.getElementById('loading-screen');
            loadingTextElement = document.getElementById('loading-text'); // Get ref

            // General cleanup when leaving game states
            if (newState === GameState.MENU) {
                resetMultiplayer();
                // Ensure UI elements exist before hiding
                const gameUI = document.getElementById('game-ui');
                const scoreP1 = document.getElementById('score-p1');
                const scoreP2 = document.getElementById('score-p2');
                const cinematicTop = document.getElementById('cinematic-top');
                const cinematicBottom = document.getElementById('cinematic-bottom');

                if (gameUI) gameUI.style.display = 'none';
                if (scoreP1) scoreP1.style.display = 'none';
                if (scoreP2) scoreP2.style.display = 'none';
                if (cinematicTop) cinematicTop.classList.remove('active', 'full');
                if (cinematicBottom) cinematicBottom.classList.remove('active', 'full');

            } else if (newState !== GameState.GAME_LOADING && newState !== GameState.CONNECTING) { // Show game UI if not in menu, loading, or connecting
                // Ensure UI elements exist before showing
                const gameUI = document.getElementById('game-ui');
                const scoreP1 = document.getElementById('score-p1');
                const scoreP2 = document.getElementById('score-p2');
                if (gameUI) gameUI.style.display = 'flex';
                if (scoreP1) scoreP1.style.display = 'block';
                if (scoreP2) scoreP2.style.display = 'block';
            }


            switch (newState) {
                case GameState.MENU: document.getElementById('main-menu').classList.add('active'); break;
                case GameState.HOSTING_MODE_SELECT: document.getElementById('mode-select').classList.add('active'); break;
                case GameState.HOSTING_GET_ANSWER: document.getElementById('get-answer').classList.add('active'); break;
                case GameState.JOINING_GET_OFFER: document.getElementById('get-offer').classList.add('active'); break;
                case GameState.JOINING_SHARE_ANSWER: document.getElementById('share-answer').classList.add('active'); break;
                case GameState.CONNECTING: document.getElementById('connecting').classList.add('active'); break;
                case GameState.GAME_LOADING:
                    if (loadingScreen) {
                        loadingScreen.classList.add('active');
                        loadingScreen.style.opacity = '1';
                    }
                    if (loadingTextElement) loadingTextElement.textContent = "Loading Assets...";
                    if (!renderer) { initThreeJS(); animate(); } // Init ONLY if it doesn't exist
                    // Map generation/loading is triggered by network events
                    break;
                case GameState.GAME_PLAYING: controlsEnabled = true; document.exitPointerLock(); hideInitialInstructions(); break;
                 case GameState.ROUND_OVER: controlsEnabled = false; if(roundOverMsgElement) roundOverMsgElement.classList.add('active'); break;
                 case GameState.CUTSCENE_START:
                    controlsEnabled = false; isPrecisionAiming = false;
                    if(vignetteElement) vignetteElement.classList.remove('active');
                    if(crosshairElement) crosshairElement.classList.remove('active');
                    if(precisionExitInstructionsElement) precisionExitInstructionsElement.classList.remove('active');
                    document.exitPointerLock();
                    if(scoreP1Element) scoreP1Element.style.display = 'none';
                    if(scoreP2Element) scoreP2Element.style.display = 'none';
                    if(cinematicTopBar) cinematicTopBar.classList.add('active');
                    if(cinematicBottomBar) cinematicBottomBar.classList.add('active');
                    cutsceneTimer = 0; scoreRevealStep = 0; scoreRevealP1 = 0; scoreRevealP2 = 0;
                    break;
                 case GameState.CUTSCENE_SCORE: if(scoreRevealElement) scoreRevealElement.classList.add('active'); break;
                 case GameState.CUTSCENE_OUTCOME: if(scoreRevealElement) scoreRevealElement.classList.remove('active'); if (localScore > remoteScore) { if(winSound && winSound.isPlaying === false) winSound.play(); } break; // Ensure sound isn't already playing
                 case GameState.CUTSCENE_END: if(cinematicTopBar) cinematicTopBar.classList.add('full'); if(cinematicBottomBar) cinematicBottomBar.classList.add('full'); break;
            }
        }

        // --- Main Menu Setup ---
        function setupMainMenu() {
            const usernameInput = document.getElementById('username');
            const colorSelect = document.getElementById('color-select');
            const hostButton = document.getElementById('host-button');
            const joinButton = document.getElementById('join-button');

            // Load saved settings
            const savedUsername = localStorage.getItem('tankUsername');
            const savedColor = localStorage.getItem('tankColor');
            if (savedUsername) { usernameInput.value = savedUsername; localUsername = savedUsername; }
            if (savedColor) { colorSelect.value = savedColor; localColor = savedColor; }

            function validateUsername() {
                const isValid = /^[a-zA-Z0-9]+$/.test(usernameInput.value);
                hostButton.disabled = !isValid; joinButton.disabled = !isValid;
                if (isValid) { localUsername = usernameInput.value; localStorage.setItem('tankUsername', localUsername); } else { localUsername = ''; }
            }
            usernameInput.addEventListener('input', validateUsername);
            validateUsername();

            colorSelect.addEventListener('change', () => { localColor = colorSelect.value; localStorage.setItem('tankColor', localColor); });

            hostButton.addEventListener('click', () => setGameState(GameState.HOSTING_MODE_SELECT));
            joinButton.addEventListener('click', () => setGameState(GameState.JOINING_GET_OFFER));

            document.querySelectorAll('#mode-select button').forEach(button => {
                button.addEventListener('click', (e) => {
                    selectedGameMode = e.target.getAttribute('data-mode');
                    console.log("Selected mode:", selectedGameMode); // Debug log
                    if (selectedGameMode === 'bo3') maxRounds = 3;
                    else if (selectedGameMode === 'bo5') maxRounds = 5;
                    else maxRounds = Infinity;
                    startHosting();
                });
            });

            // Cancel Buttons
            document.getElementById('cancel-host-button').addEventListener('click', () => setGameState(GameState.MENU));
            document.getElementById('cancel-join-button').addEventListener('click', () => setGameState(GameState.MENU));
            document.getElementById('cancel-join-button-2').addEventListener('click', () => setGameState(GameState.MENU));

             // Submit Buttons
             document.getElementById('submit-answer-button').addEventListener('click', () => {
                 const answerCode = document.getElementById('answer-code-input').value;
                 if (answerCode && peer) { try { peer.signal(JSON.parse(answerCode)); setGameState(GameState.CONNECTING); } catch (err) { alert("Invalid Answer Code."); } } else { alert("Paste Answer Code."); }
             });
             document.getElementById('submit-offer-button').addEventListener('click', () => {
                 const offerCode = document.getElementById('offer-code-input').value;
                 if (offerCode) { startJoining(offerCode); } else { alert("Paste Offer Code."); }
             });

            // Copy Buttons
            document.getElementById('copy-offer-button').addEventListener('click', () => copyToClipboard('offer-code-display'));
            document.getElementById('copy-answer-button').addEventListener('click', () => copyToClipboard('answer-code'));
        }

        function copyToClipboard(elementId) {
            const textElement = document.getElementById(elementId);
            const textToCopy = textElement.textContent || textElement.innerText;
             if (navigator.clipboard) { navigator.clipboard.writeText(textToCopy).then(() => console.log('Copied!')).catch(err => fallbackCopyTextToClipboard(textToCopy)); }
             else { fallbackCopyTextToClipboard(textToCopy); }
        }

        function fallbackCopyTextToClipboard(text) {
            const textArea = document.createElement("textarea");
            textArea.value = text;
            textArea.style.position = "absolute"; textArea.style.left = "-9999px"; // Prevent scroll jump
            document.body.appendChild(textArea);
            textArea.focus(); textArea.select();
            try { document.execCommand('copy'); console.log('Code copied (fallback)!'); }
            catch (err) { console.error('Fallback copy failed: ', err); }
            document.body.removeChild(textArea);
        }

        // --- Multiplayer Functions ---
        function startHosting() {
            isHost = true; localPlayerId = 'p1'; remotePlayerId = 'p2'; resetMultiplayer();
            setGameState(GameState.CONNECTING);
            peer = new SimplePeer({ initiator: true, trickle: false });
            peer.on('error', (err) => { console.error('Peer Error:', err); alert("Connection error."); setGameState(GameState.MENU); });
            peer.on('close', () => { if (currentGameState !== GameState.MENU) { alert("Opponent disconnected."); setGameState(GameState.MENU); } resetMultiplayer(); });
            peer.on('signal', (data) => {
                document.getElementById('offer-code-display').textContent = JSON.stringify(data);
                setGameState(GameState.HOSTING_GET_ANSWER);
            });
            peer.on('connect', () => { console.log('Peer connected! (Host)'); sendInitialHandshake(); /* Wait for joiner handshake */ });
            peer.on('data', handleIncomingData);
        }

        function startJoining(offerCode) {
            isHost = false; localPlayerId = 'p2'; remotePlayerId = 'p1'; resetMultiplayer();
            setGameState(GameState.CONNECTING);
            peer = new SimplePeer({ initiator: false, trickle: false });
            peer.on('error', (err) => { console.error('Peer Error:', err); alert("Connection error."); setGameState(GameState.MENU); });
            peer.on('close', () => { if (currentGameState !== GameState.MENU) { alert("Opponent disconnected."); setGameState(GameState.MENU); } resetMultiplayer(); });
            peer.on('signal', (data) => {
                document.getElementById('answer-code').textContent = JSON.stringify(data);
                setGameState(GameState.JOINING_SHARE_ANSWER);
            });
            peer.on('connect', () => { console.log('Peer connected! (Joiner)'); sendInitialHandshake(); /* Wait for host map data */ });
            peer.on('data', handleIncomingData);
            try { peer.signal(JSON.parse(offerCode)); } catch (err) { alert("Invalid Offer Code."); setGameState(GameState.MENU); }
        }

        function sendInitialHandshake() { sendData({ type: 'handshake', username: localUsername, color: localColor, gameMode: isHost ? selectedGameMode : undefined }); }

        function handleIncomingData(data) {
            try {
                const message = JSON.parse(data.toString());
                switch (message.type) {
                    case 'handshake':
                        remoteUsername = message.username; remoteColor = message.color;
                        if (isHost) {
                            console.log('Host received joiner handshake.');
                            setGameState(GameState.GAME_LOADING); // Show loading
                            mapData = generateMapData();
                            sendData({ type: 'map_data', data: mapData });
                            createMapFromData(mapData);
                            hostReady = true;
                            if (joinerReady) startGame(); else loadingTextElement.textContent = "Waiting for player...";
                        } else {
                            console.log('Joiner received host handshake.');
                            selectedGameMode = message.gameMode;
                            if (selectedGameMode === 'bo3') maxRounds = 3; else if (selectedGameMode === 'bo5') maxRounds = 5; else maxRounds = Infinity;
                            loadingTextElement.textContent = "Loading map...";
                        }
                        updateScoreUI();
                        break;
                    case 'map_data':
                         if (!isHost) {
                            console.log('Joiner received map data.');
                            setGameState(GameState.GAME_LOADING); // Ensure loading state
                            mapData = message.data;
                            createMapFromData(mapData);
                            sendData({ type: 'map_loaded' });
                            joinerReady = true;
                            if (hostReady) startGame(); else loadingTextElement.textContent = "Waiting for host...";
                         }
                         break;
                    case 'map_loaded':
                         if (isHost) {
                             console.log('Host received map loaded confirmation.');
                             joinerReady = true;
                             if (hostReady) startGame(); else console.log("Host map not ready yet?"); // Should not happen
                         }
                        break;
                    // case 'start_game': // Redundant now, startGame called when both ready
                    //      if (!isHost && hostReady && joinerReady) { startGame(); }
                    //     break;
                    case 'state_update':
                         remoteTankState.targetPosition.fromArray(message.state.position); // Use fromArray
                         remoteTankState.targetYaw = message.state.yaw;
                         remoteTankState.targetHeadYaw = message.state.headYaw;
                         remoteTankState.targetTurretPitch = message.state.turretPitch;
                         remoteTankState.health = message.state.health; // Update health from network
                         remoteTankState.lastUpdateTimestamp = Date.now();
                         break;
                    case 'shoot': spawnRemoteBullet(message.position, message.direction); break;
                    case 'hit':
                         if (message.targetId === localPlayerId) {
                              localTankState.health -= message.damage; localTankState.health = Math.max(0, localTankState.health); updateHealthBar(); cameraShakeIntensity += 0.5;
                              console.log(`I was hit! Health: ${localTankState.health.toFixed(0)}`);
                              if (localTankState.health <= 0 && localTankState.isAlive) { handlePlayerDeath(localPlayerId); } // Check isAlive
                         } else { // It was the remote player hit
                             remoteTankState.health -= message.damage; // Update remote health estimate
                             remoteTankState.health = Math.max(0, remoteTankState.health); // Clamp health
                             console.log(`Opponent hit! Their health (estimated): ${remoteTankState.health.toFixed(0)}`);
                             if (remoteTankState.health <= 0 && remoteTankState.isAlive) { handlePlayerDeath(remotePlayerId); } // Check isAlive
                         }
                        break;
                    case 'round_over_ack': if (!isHost && currentGameState === GameState.ROUND_OVER) { setTimeout(startNextRoundOrCutscene, 3000); } break;
                    case 'request_rematch': /* ... */ break;
                    case 'accept_rematch': resetScoresAndStartGame(); break;
                }
            } catch (err) { console.error('Error parsing data:', err, data.toString()); }
        }

        function sendData(data) { if (peer && peer.connected) { try { peer.send(JSON.stringify(data)); } catch(e){ console.error("Send Error:", e)} } else { console.warn("Peer not connected."); } }
        function resetMultiplayer() { if (peer) { peer.destroy(); peer = null; } localScore = 0; remoteScore = 0; currentRound = 1; remoteUsername = 'Player 2'; remoteColor = '#0000ff'; isHost = false; hostReady = false; joinerReady = false; mapData = null; }

        // --- Start Game Function ---
        function startGame() {
            if (hostReady && joinerReady && currentGameState === GameState.GAME_LOADING) { // Only start if loading
                 console.log("Both players ready! Starting game.");
                 resetRound();
                 setGameState(GameState.GAME_PLAYING);
                 const loadingScreen = document.getElementById('loading-screen');
                 loadingScreen.style.opacity = '0';
                 setTimeout(() => { loadingScreen.style.display = 'none'; }, 1000);
            } else { console.log("Waiting for players/correct state:", { hostReady, joinerReady, currentGameState }); loadingTextElement.textContent = isHost ? "Waiting for player..." : "Waiting for host..."; }
        }


        // --- Init Three.js ---
        function initThreeJS() {
            // Get UI elements
            scoreP1Element = document.getElementById('score-p1'); scoreP2Element = document.getElementById('score-p2'); roundOverMsgElement = document.getElementById('round-over-message');
            cinematicTopBar = document.getElementById('cinematic-top'); cinematicBottomBar = document.getElementById('cinematic-bottom'); scoreRevealElement = document.getElementById('score-reveal');
            scoreRevealP1Span = document.getElementById('score-reveal-p1'); scoreRevealP2Span = document.getElementById('score-reveal-p2'); scoreRevealSeparatorSpan = document.getElementById('score-reveal-separator');
            healthBarFill = document.getElementById('health-bar-fill'); reloadBarFill = document.getElementById('reload-bar-fill'); vignetteElement = document.getElementById('vignette'); crosshairElement = document.getElementById('crosshair'); actionInstructionsElement = document.getElementById('action-instructions'); initialInstructionsElement = document.getElementById('initial-instructions'); precisionExitInstructionsElement = document.getElementById('precision-exit-instructions');
            loadingTextElement = document.getElementById('loading-text');

            // Basic Three Setup
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87ceeb); scene.fog = new THREE.Fog(0x87ceeb, 0, 400);
            camera = new THREE.PerspectiveCamera(defaultFov, window.innerWidth / window.innerHeight, 1, 2000); camera.position.set(0, 20, 20);
            audioListener = new THREE.AudioListener(); camera.add(audioListener);
            renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setPixelRatio(window.devicePixelRatio); renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
            clock = new THREE.Clock();
            raycaster = new THREE.Raycaster(); collisionRaycaster = new THREE.Raycaster(); bulletRaycaster = new THREE.Raycaster();
            muzzleDebugArrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,-1), new THREE.Vector3(0,0,0), 10, 0xff00ff); scene.add(muzzleDebugArrow); muzzleDebugArrow.visible = false;
            const trajectoryMaterial = new THREE.LineDashedMaterial({ color: 0x0000ff, dashSize: 0.5, gapSize: 0.3 }); const trajectoryGeometry = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(180 * 3), 3));
            trajectoryLine = new THREE.Line(trajectoryGeometry, trajectoryMaterial); trajectoryLine.frustumCulled = false; trajectoryLine.visible = false; scene.add(trajectoryLine);
            scene.add(debugHelpers); debugHelpers.visible = isDebugMode;

            // Load Assets (Explosion, Sounds, Particles)
            const textureLoader = new THREE.TextureLoader(mainLoadingManager);
            explosionSpriteSheet = textureLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/texture/explose.png', () => { explosionMaterial = new THREE.MeshBasicMaterial({ map: explosionSpriteSheet, transparent: true, side: THREE.DoubleSide, depthWrite: false }); });
            const audioLoader = new THREE.AudioLoader(mainLoadingManager);
            audioLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/sounds/explosion-312361.mp3', (buffer) => { explosionSoundBuffer = buffer; });
            audioLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/sounds/winsound.mp3', (buffer) => { winSoundBuffer = buffer; winSound = new THREE.Audio(audioListener); winSound.setBuffer(winSoundBuffer); winSound.setVolume(0.5); });
            woodParticleGeometry = new THREE.BoxGeometry(0.1, 0.4, 0.1); woodParticleMaterial = new THREE.MeshBasicMaterial({ color: 0x5c3a21 });

            // Create Tanks (visual structure only)
            localTank = createTankVisuals(); // Color applied in loadTankModels
            scene.add(localTank);
            tankHeadPivotLocal = localTank.getObjectByName('headPivot');
            tankTurretPivotLocal = localTank.getObjectByName('turretPivot');

            remoteTank = createTankVisuals(); // Color applied in loadTankModels
            scene.add(remoteTank);
            tankHeadPivotRemote = remoteTank.getObjectByName('headPivot');
            tankTurretPivotRemote = remoteTank.getObjectByName('turretPivot');

            // Load Tank Models into the created groups
            loadTankModels(mainLoadingManager, localTank, remoteTank);


            // Lights
            const hemisphereLight = new THREE.HemisphereLight(0x87ceeb, 0x00ff00, 0.8); scene.add(hemisphereLight);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); directionalLight.position.set(50, 100, 50); directionalLight.castShadow = true; scene.add(directionalLight);

            // Event Listeners for Game
            document.addEventListener('keydown', onKeyDown); document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown); document.addEventListener('mouseup', onMouseUp); document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('contextmenu', onContextMenu); document.addEventListener('wheel', onMouseWheel);
            document.addEventListener('pointerlockchange', onPointerLockChange, false); document.addEventListener('pointerlockerror', onPointerLockError, false);
            window.addEventListener('resize', onWindowResize);

            updateScoreUI();
        }


        // --- Create Tank Visual Structure ---
        function createTankVisuals() { // Removed color parameter
            const tankGroup = new THREE.Group();

            // Physics Box (Invisible)
            const playerGeometry = new THREE.BoxGeometry(2.5, 0.5, 3);
            const playerMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, transparent: true, opacity: 0 }); // INVISIBLE
            const playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
            playerMesh.position.y = 0.25;
            tankGroup.add(playerMesh); // Add invisible box as first child

            // Head Pivot
            const headPivot = new THREE.Group();
            headPivot.name = 'headPivot';
            headPivot.position.copy(tankHeadPivotPosition);
            tankGroup.add(headPivot);

             // Pivot Marker (Add here, relative to tank group)
             const pivotMarkerGeom = new THREE.WireframeGeometry(new THREE.SphereGeometry(0.5, 8, 8));
             const pivotMarkerMat = new THREE.MeshBasicMaterial({ color: 0xff00ff, wireframe: true });
             const headPivotMarker = new THREE.Mesh(pivotMarkerGeom, pivotMarkerMat);
             headPivotMarker.position.copy(tankHeadPivotPosition); // Position it where the pivot is
             tankGroup.add(headPivotMarker);
             headPivotMarker.visible = isDebugMode;
             tankGroup.userData.headPivotMarker = headPivotMarker; // Store ref


            // Turret Pivot (Child of Head Pivot)
            const turretPivot = new THREE.Group();
            turretPivot.name = 'turretPivot';
            turretPivot.position.copy(turretPivotPosition);
            headPivot.add(turretPivot); // Add turret pivot to head pivot

            // Turret Pivot Marker (Add here, relative to head pivot)
             const turretPivotMarkerGeom = new THREE.WireframeGeometry(new THREE.SphereGeometry(0.5, 8, 8));
             const turretPivotMarkerMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true });
             const turretPivotMarkerMesh = new THREE.Mesh(turretPivotMarkerGeom, turretPivotMarkerMat);
             turretPivotMarkerMesh.position.copy(turretPivotPosition); // Position relative to head pivot
             headPivot.add(turretPivotMarkerMesh); // Add marker TO HEAD PIVOT
             turretPivotMarkerMesh.visible = isDebugMode;
             tankGroup.userData.turretPivotMarker = turretPivotMarkerMesh; // Store ref


             // --- Placeholders WITHOUT color ---
             const placeholderMat = new THREE.MeshBasicMaterial({visible: false}); // Invisible placeholders

             const bodyPlaceholder = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), placeholderMat); bodyPlaceholder.name = "bodyPlaceholder"; tankGroup.add(bodyPlaceholder);
             const headPlaceholder = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), placeholderMat); headPlaceholder.name = "headPlaceholder"; headPivot.add(headPlaceholder);
             const turretPlaceholder = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,2), placeholderMat); turretPlaceholder.name = "turretPlaceholder"; turretPivot.add(turretPlaceholder);

            return tankGroup;
        }

        // --- Load Actual Tank Models ---
        function loadTankModels(manager, localTankGroup, remoteTankGroup) {
             const mtlLoader = new MTLLoader(manager);
             const objLoader = new OBJLoader(manager);

             // --- Load Body ---
             mtlLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/tank/body.mtl', (materials) => {
                  materials.preload(); objLoader.setMaterials(materials);
                  objLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/tank/body.obj', (object) => {
                       object.scale.setScalar(bodyModelScale); object.position.copy(bodyModelPositionOffset); object.rotation.copy(bodyModelRotationOffset);
                       // --- REMOVED COLOR APPLICATION ---
                       const localPlaceholder = localTankGroup.getObjectByName("bodyPlaceholder"); if(localPlaceholder) localTankGroup.remove(localPlaceholder); localTankGroup.add(object.clone()); // Add cloned model
                       // --- REMOVED COLOR APPLICATION ---
                       const remotePlaceholder = remoteTankGroup.getObjectByName("bodyPlaceholder"); if(remotePlaceholder) remoteTankGroup.remove(remotePlaceholder); remoteTankGroup.add(object.clone()); // Add cloned model
                  });
             });

             // --- Load Head ---
             mtlLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/tank/head.mtl', (materials) => {
                  materials.preload(); objLoader.setMaterials(materials);
                  objLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/tank/head.obj', (object) => {
                       object.scale.setScalar(headModelScale); object.position.copy(headModelPositionOffset); object.rotation.copy(headModelRotationOffset);
                       const localHeadPivot = localTankGroup.getObjectByName('headPivot'); const remoteHeadPivot = remoteTankGroup.getObjectByName('headPivot');
                       // --- REMOVED COLOR APPLICATION ---
                       const localPlaceholder = localHeadPivot?.getObjectByName("headPlaceholder"); if(localPlaceholder) localHeadPivot.remove(localPlaceholder); if(localHeadPivot) localHeadPivot.add(object.clone());
                       // --- REMOVED COLOR APPLICATION ---
                       const remotePlaceholder = remoteHeadPivot?.getObjectByName("headPlaceholder"); if(remotePlaceholder) remoteHeadPivot.remove(remotePlaceholder); if(remoteHeadPivot) remoteHeadPivot.add(object.clone());
                  });
             });

             // --- Load Turret ---
             mtlLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/tank/turret.mtl', (materials) => {
                  materials.preload(); objLoader.setMaterials(materials);
                  objLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/tank/turret.obj', (object) => {
                       object.scale.setScalar(turretModelScale); object.position.copy(turretModelPosition); object.rotation.copy(turretModelRotation); object.name = "turretModel"; // Assign name
                       const localTurretPivot = localTankGroup.getObjectByName('turretPivot'); const remoteTurretPivot = remoteTankGroup.getObjectByName('turretPivot');
                       // --- REMOVED COLOR APPLICATION ---
                       const localPlaceholder = localTurretPivot?.getObjectByName("turretPlaceholder"); if(localPlaceholder) localTurretPivot.remove(localPlaceholder);
                       if(localTurretPivot) { const localTurret = object.clone(); localTurretPivot.add(localTurret); tankTurretModelLocal = localTurret; } // Assign local ref
                       // --- REMOVED COLOR APPLICATION ---
                       const remotePlaceholder = remoteTurretPivot?.getObjectByName("turretPlaceholder"); if(remotePlaceholder) remoteTurretPivot.remove(remotePlaceholder);
                       if(remoteTurretPivot) { const remoteTurret = object.clone(); remoteTurretPivot.add(remoteTurret); tankTurretModelRemote = remoteTurret; } // Assign remote ref
                  });
             });
        }


        // --- Map Data Generation ---
        function generateMapData() {
            const data = { terrain: [], warehouses: [], trees: [], barriers: [] };
            // Terrain
            const tempGeo = new THREE.PlaneGeometry(500, 500, 100, 100); const positions = tempGeo.attributes.position; const vertex = new THREE.Vector3();
            const amp1 = 8; const freq1 = 0.005; const amp2 = 3; const freq2 = 0.02;
            for (let i = 0; i < positions.count; i++) { vertex.fromBufferAttribute(positions, i); const zOffset = Math.sin(vertex.x * freq1) * Math.cos(vertex.y * freq1) * amp1 + Math.sin(vertex.x * freq2) * Math.cos(vertex.y * freq2) * amp2; data.terrain.push(zOffset); }
            tempGeo.dispose();
            // Decorations
            const spawnRange = SPAWN_AREA / 2;
            const warehouseCount = THREE.MathUtils.randInt(MIN_WAREHOUSES, MAX_WAREHOUSES); for (let i = 0; i < warehouseCount; i++) { data.warehouses.push({ x: THREE.MathUtils.randFloat(-spawnRange, spawnRange), z: THREE.MathUtils.randFloat(-spawnRange, spawnRange), rotY: Math.random() * Math.PI * 2 }); }
            const treeCount = THREE.MathUtils.randInt(MIN_TREES, MAX_TREES); for (let i = 0; i < treeCount; i++) { data.trees.push({ x: THREE.MathUtils.randFloat(-spawnRange, spawnRange), z: THREE.MathUtils.randFloat(-spawnRange, spawnRange), rotY: Math.random() * Math.PI * 2, scale: treeScale + THREE.MathUtils.randFloat(0.0, treeScaleVariation) }); }
            const barrierCount = THREE.MathUtils.randInt(MIN_BARRIERS, MAX_BARRIERS); for (let i = 0; i < barrierCount; i++) { data.barriers.push({ x: THREE.MathUtils.randFloat(-spawnRange, spawnRange), z: THREE.MathUtils.randFloat(-spawnRange, spawnRange), rotY: Math.random() * Math.PI * 2 }); }
            console.log("Generated map data:", data);
            return data;
        }

        // --- Create Map From Data ---
        function createMapFromData(mapData) {
             console.log("Creating map from data...");
             removeMap(); // Clear existing map objects

             // Create Ground
             const groundGeometry = new THREE.PlaneGeometry(500, 500, 100, 100); const positions = groundGeometry.attributes.position;
             if (positions.count === mapData.terrain.length) { for (let i = 0; i < positions.count; i++) { positions.setZ(i, mapData.terrain[i]); } } else { console.error("Terrain data length mismatch!"); }
             groundGeometry.computeVertexNormals();
             const textureLoader = new THREE.TextureLoader(mainLoadingManager);
             const grassTexture = textureLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/texture/grass.jpg', (texture)=>{ texture.wrapS = THREE.RepeatWrapping; texture.wrapT = THREE.RepeatWrapping; texture.repeat.set(25, 25); if(ground && ground.material) ground.material.needsUpdate = true;});
             const groundMaterial = new THREE.MeshStandardMaterial({ color: 0xffffff, map: grassTexture, side: THREE.DoubleSide });
             ground = new THREE.Mesh(groundGeometry, groundMaterial); ground.rotation.x = -Math.PI / 2; scene.add(ground);

             // Load decorations using the data
             loadDecorationsFromData(mapData, mainLoadingManager);
        }

         // --- Load Decorations From Data ---
        function loadDecorationsFromData(mapData, manager) {
            const gltfLoader = new GLTFLoader(manager);
            const groundRaycaster = new THREE.Raycaster();

             // Load Warehouse Model
             gltfLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/warehouse.glb', (gltf) => {
                  const baseWarehouse = gltf.scene;
                  mapData.warehouses.forEach(data => {
                       const warehouse = baseWarehouse.clone(); warehouse.userData.type = 'warehouse'; warehouse.scale.setScalar(warehouseScale); warehouse.rotation.y = data.rotY;
                       const rayStart = new THREE.Vector3(data.x, 100, data.z); groundRaycaster.set(rayStart, new THREE.Vector3(0, -1, 0)); const intersects = groundRaycaster.intersectObject(ground);
                       if (intersects.length > 0) warehouse.position.set(data.x, intersects[0].point.y + warehouseYOffset, data.z); else warehouse.position.set(data.x, warehouseYOffset, data.z);
                       warehouse.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; }}); scene.add(warehouse); collidables.push(warehouse); warehouse.boundingBox = new THREE.Box3().setFromObject(warehouse);
                       const boxHelper = new THREE.BoxHelper(warehouse, 0xff0000); warehouse.debugBox = boxHelper; debugHelpers.add(boxHelper);
                       const lineGeom = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3)); warehouse.debugLine = new THREE.Line(lineGeom, new THREE.LineBasicMaterial({color: 0x0000ff})); debugHelpers.add(warehouse.debugLine);
                  });
             });

             // Load Tree Model
             gltfLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/giant_low_poly_tree.glb', (gltf) => {
                  const baseTree = gltf.scene; trees.length = 0;
                  mapData.trees.forEach(data => {
                       const tree = baseTree.clone(); tree.userData.type = 'tree'; tree.scale.setScalar(data.scale); tree.rotation.y = data.rotY;
                       const rayStart = new THREE.Vector3(data.x, 100, data.z); groundRaycaster.set(rayStart, new THREE.Vector3(0, -1, 0)); const intersects = groundRaycaster.intersectObject(ground);
                       if (intersects.length > 0) tree.position.set(data.x, intersects[0].point.y + treeYOffset, data.z); else tree.position.set(data.x, treeYOffset, data.z);
                       tree.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; }}); scene.add(tree); collidables.push(tree); tree.boundingBox = new THREE.Box3().setFromObject(tree); trees.push(tree);
                       const boxHelper = new THREE.BoxHelper(tree, 0xff8800); tree.debugBox = boxHelper; debugHelpers.add(boxHelper);
                       const lineGeom = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3)); tree.debugLine = new THREE.Line(lineGeom, new THREE.LineBasicMaterial({color: 0x00ff00})); debugHelpers.add(tree.debugLine);
                  });
             });

             // Load Barrier Model
             gltfLoader.load('https://raw.githubusercontent.com/haf1-gli/haf1-gli.github.io/main/assets/models/concrete_armored_barrier.glb', (gltf) => {
                  const baseBarrier = gltf.scene; barriers.length = 0;
                  mapData.barriers.forEach(data => {
                       const barrier = baseBarrier.clone(); barrier.userData.type = 'barrier'; barrier.scale.setScalar(barrierScale); barrier.rotation.y = data.rotY;
                       const rayStart = new THREE.Vector3(data.x, 100, data.z); groundRaycaster.set(rayStart, new THREE.Vector3(0, -1, 0)); const intersects = groundRaycaster.intersectObject(ground);
                       if (intersects.length > 0) barrier.position.set(data.x, intersects[0].point.y + barrierYOffset, data.z); else barrier.position.set(data.x, barrierYOffset, data.z);
                       barrier.traverse(c=>{ if(c.isMesh){ c.castShadow=true; c.receiveShadow=true; }}); scene.add(barrier); collidables.push(barrier); barrier.boundingBox = new THREE.Box3().setFromObject(barrier); barriers.push(barrier);
                       const boxHelper = new THREE.BoxHelper(barrier, 0xff88ff); barrier.debugBox = boxHelper; debugHelpers.add(boxHelper);
                       const lineGeom = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(6), 3)); barrier.debugLine = new THREE.Line(lineGeom, new THREE.LineBasicMaterial({color: 0x8888ff})); debugHelpers.add(barrier.debugLine);
                  });
             });
        }


        // --- Toggle Precision Aim Function ---
        function togglePrecisionAim() {
            isPrecisionAiming = !isPrecisionAiming;
            if (isPrecisionAiming) {
                renderer.domElement.requestPointerLock();
                vignetteElement.classList.add('active'); crosshairElement.classList.add('active'); precisionExitInstructionsElement.classList.add('active');
                thirdPersonCamPos.copy(camera.position);
            } else {
                document.exitPointerLock();
                vignetteElement.classList.remove('active'); crosshairElement.classList.remove('active'); precisionExitInstructionsElement.classList.remove('active');
                precisionZoomLevel = 0; isFollowingBullet = false;
            }
        }

        // --- Shooting Functions ---
        function shoot() {
            if (!canShoot || !tankTurretPivotLocal || isRegeneratingMap || !isReloaded || !localTankState.isAlive || currentGameState !== GameState.GAME_PLAYING) return;
            canShoot = false; setTimeout(() => { canShoot = true; }, shootCooldown * 1000);
            isReloaded = false; reloadProgress = 0.0; updateReloadBar(); updateActionInstructions();

            // Use turret PIVOT's world position/rotation + muzzle offset
            muzzleWorldPos.copy(muzzlePosition);
            tankTurretPivotLocal.localToWorld(muzzleWorldPos); // Start from turret pivot + muzzle offset

            muzzleDirection.set(0, 0, -1); // Assuming -Z is forward for the turret *model*
            tankTurretPivotLocal.getWorldQuaternion(muzzleWorldQuat); // Get pivot's world rotation
            muzzleOffsetQuat.setFromEuler(muzzleRotation); // Apply muzzle offset rotation
            muzzleWorldQuat.multiply(muzzleOffsetQuat);
            muzzleDirection.applyQuaternion(muzzleWorldQuat).normalize();

            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            bullet.position.copy(muzzleWorldPos);
            bullet.velocity = muzzleDirection.clone().multiplyScalar(bulletSpeed);
            bullet.age = 0; bullet.lastPosition = bullet.position.clone(); bullet.isBullet = true;
            bullet.ownerId = localPlayerId; // Mark owner

            scene.add(bullet); bullets.push(bullet);

            // Send shoot event to opponent
            sendData({ type: 'shoot', position: bullet.position.toArray(), direction: bullet.velocity.toArray() });

            if (isPrecisionAiming) { isFollowingBullet = true; followBulletTimer = 0; followBulletStartPos.copy(camera.position); followBulletDirection.copy(muzzleDirection); }
        }

        function spawnRemoteBullet(positionArray, directionArray) {
             const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
             bullet.position.fromArray(positionArray);
             bullet.velocity = new THREE.Vector3().fromArray(directionArray);
             bullet.age = 0; bullet.lastPosition = bullet.position.clone(); bullet.isBullet = true;
             bullet.ownerId = remotePlayerId;
             scene.add(bullet); bullets.push(bullet);
        }


        function updateBullets(delta) {
             for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i]; bullet.lastPosition.copy(bullet.position); bullet.velocity.y -= bulletGravityStrength * delta; bullet.position.add(bullet.velocity.clone().multiplyScalar(delta));
                const bulletTravelVec = bullet.position.clone().sub(bullet.lastPosition); const bulletTravelDist = bulletTravelVec.length(); bulletTravelVec.normalize();
                if (bulletTravelDist > 0) {
                    bulletRaycaster.set(bullet.lastPosition, bulletTravelVec); bulletRaycaster.far = bulletTravelDist;
                    const objectsToHit = [ground, ...collidables]; const intersects = bulletRaycaster.intersectObjects(objectsToHit, true);
                    const localTankMesh = localTank ? localTank.children[0] : null; // Get physics box
                    const remoteTankMesh = remoteTank ? remoteTank.children[0] : null; // Get physics box
                    let hitTankId = null;
                    let hitPosition = null;

                    if (localTankMesh && bullet.ownerId !== localPlayerId && localTankState.isAlive) {
                         const hitLocal = bulletRaycaster.intersectObject(localTankMesh);
                         if (hitLocal.length > 0 && hitLocal[0].distance <= bulletTravelDist) { hitTankId = localPlayerId; hitPosition = hitLocal[0].point; }
                    }
                    if (!hitTankId && remoteTankMesh && bullet.ownerId !== remotePlayerId && remoteTankState.isAlive) {
                         const hitRemote = bulletRaycaster.intersectObject(remoteTankMesh);
                         if (hitRemote.length > 0 && hitRemote[0].distance <= bulletTravelDist) { hitTankId = remotePlayerId; hitPosition = hitRemote[0].point; }
                    }

                    if (hitTankId) {
                        console.log(`Bullet hit tank ${hitTankId}`);
                         createExplosion(hitPosition);
                         if (bullet.ownerId === localPlayerId) { // Only sender reports the hit damage
                              const damage = explosionMaxDamage;
                              sendData({ type: 'hit', targetId: hitTankId, damage: damage });
                              if (hitTankId === remotePlayerId) { remoteTankState.health -= damage; remoteTankState.health = Math.max(0, remoteTankState.health); console.log(`Direct hit on opponent! Their health (est): ${remoteTankState.health.toFixed(0)}`); if (remoteTankState.health <= 0 && remoteTankState.isAlive) handlePlayerDeath(remotePlayerId); }
                         }
                         removeBullet(bullet, i); continue;
                    } else if (intersects.length > 0) { createExplosion(intersects[0].point); removeBullet(bullet, i); continue; }
                }
                bullet.age += delta; if (bullet.age > 5.0) { removeBullet(bullet, i); }
            }
        }
        function removeBullet(bullet, index) { scene.remove(bullet); bullets.splice(index, 1); }

        // --- Explosion Function (UPDATED for Multiplayer) ---
        function createExplosion(position) {
            if (!explosionMaterial || !explosionSoundBuffer) return;
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial.clone());
            explosion.position.copy(position); explosion.scale.setScalar(0.1 * (explosionSize / 10.0));
            explosion.userData.age = 0; explosion.userData.currentFrame = 0;
            const sound = new THREE.PositionalAudio(audioListener);
            sound.setBuffer(explosionSoundBuffer); sound.setRefDistance(10); sound.setRolloffFactor(1); sound.setMaxDistance(100); sound.setVolume(1.0);
            explosion.add(sound); explosion.userData.audio = sound;
            scene.add(explosion); explosions.push(explosion); sound.play();

            // Local Player Shake (Only check LOCAL player)
            if (localTankState.isAlive) {
                const distanceToPlayer = position.distanceTo(localTankState.position); const maxShakeDistance = 30;
                if (distanceToPlayer < maxShakeDistance) { const shakeRatio = 1.0 - THREE.MathUtils.clamp(distanceToPlayer / maxShakeDistance, 0, 1); const baseShake = 0.1; const proximityShake = shakeRatio * 0.3; cameraShakeIntensity += baseShake + proximityShake; }
                // Damage is handled by 'hit' message
            }
            // Collidable Damage (Both clients handle this for visual consistency)
            for (let i = collidables.length - 1; i >= 0; i--) {
                 const collidable = collidables[i]; const distance = position.distanceTo(collidable.position);
                 if (!collidable.boundingBox) continue; // Skip if no bounding box
                 collidable.boundingBox.getSize(collidableBoxSize); const collidableRadius = Math.max(collidableBoxSize.x, collidableBoxSize.z) / 2;
                 if (distance < explosionBlastRadius + collidableRadius) {
                     if (collidable.userData.type === 'tree') { spawnWoodParticles(collidable.position); removeCollidable(collidable, i); }
                 }
            }
        }

        // --- Update Explosion ---
        function updateExplosions(delta) {
            for (let i = explosions.length - 1; i >= 0; i--) {
                const explosion = explosions[i]; explosion.userData.age += delta; const progress = explosion.userData.age / explosionDuration;
                if (progress >= 1) {
                    if (explosion.userData.audio && explosion.userData.audio.isPlaying) explosion.userData.audio.stop();
                    scene.remove(explosion);
                    // Dispose cloned material, map might be shared, be careful
                    // if (explosion.material.map) explosion.material.map.dispose();
                    if(explosion.material) explosion.material.dispose();
                    explosions.splice(i, 1);
                } else {
                    const frame = Math.floor(progress * explosionTotalFrames);
                    if (frame !== explosion.userData.currentFrame) {
                        explosion.userData.currentFrame = frame; const row = Math.floor(frame / explosionCols); const col = frame % explosionCols;
                        if (explosion.material && explosion.material.map) { // Check material and map
                            explosion.material.map.offset.x = col / explosionCols; explosion.material.map.offset.y = 1.0 - (row + 1) / explosionRows;
                            explosion.material.map.repeat.set(1 / explosionCols, 1 / explosionRows);
                        }
                    }
                    explosion.scale.setScalar(THREE.MathUtils.lerp(0.1 * (explosionSize / 10.0), explosionSize, progress));
                    explosion.lookAt(camera.position);
                }
            }
        }

        function removeCollidable(collidable, index) {
             scene.remove(collidable); collidables.splice(index, 1);
             if (collidable.userData.type === 'tree') { const treeIndex = trees.indexOf(collidable); if (treeIndex > -1) trees.splice(treeIndex, 1); }
             else if (collidable.userData.type === 'barrier') { const barrierIndex = barriers.indexOf(collidable); if (barrierIndex > -1) barriers.splice(barrierIndex, 1); }
             if (collidable.debugBox) { debugHelpers.remove(collidable.debugBox); collidable.debugBox.geometry.dispose(); collidable.debugBox.material.dispose(); }
             if (collidable.debugLine) { debugHelpers.remove(collidable.debugLine); collidable.debugLine.geometry.dispose(); collidable.debugLine.material.dispose(); }
             collidable.traverse(child => { if (child.isMesh) { if(child.geometry) child.geometry.dispose(); if (child.material) { if (child.material.map) child.material.map.dispose(); child.material.dispose(); } } });
        }

        // --- Particle Functions ---
        function spawnWoodParticles(position) {
            if (!woodParticleGeometry || !woodParticleMaterial) return;
            const count = THREE.MathUtils.randInt(10, 15);
            for (let i = 0; i < count; i++) {
                const particle = new THREE.Mesh(woodParticleGeometry, woodParticleMaterial);
                particle.position.copy(position).add( new THREE.Vector3( (Math.random() - 0.5) * 2, Math.random() * 1.5, (Math.random() - 0.5) * 2 ));
                particle.scale.set( THREE.MathUtils.randFloat(0.5, 1.5), THREE.MathUtils.randFloat(1.0, 3.0), THREE.MathUtils.randFloat(0.5, 1.5) );
                const velocity = new THREE.Vector3( (Math.random() - 0.5) * 10, Math.random() * 5 + 5, (Math.random() - 0.5) * 10 );
                const rotationSpeed = new THREE.Vector3( (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5, (Math.random() - 0.5) * 5 );
                particle.userData = { velocity: velocity, rotationSpeed: rotationSpeed, age: 0 };
                scene.add(particle); particles.push(particle);
            }
        }

        function updateParticles(delta) {
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i]; const data = particle.userData;
                data.velocity.y -= particleGravity * delta; particle.position.add(data.velocity.clone().multiplyScalar(delta));
                particle.rotation.x += data.rotationSpeed.x * delta; particle.rotation.y += data.rotationSpeed.y * delta; particle.rotation.z += data.rotationSpeed.z * delta;
                data.age += delta; if (data.age >= particleLifespan) { scene.remove(particle); particles.splice(i, 1); }
            }
        }

        // --- UI Update Functions ---
        function updateHealthBar() { if (healthBarFill && localTankState) { healthBarFill.style.width = `${(localTankState.health / maxPlayerHealth) * 100}%`; } }
        function updateReloadBar() { if (reloadBarFill) { reloadBarFill.style.width = `${reloadProgress * 100}%`; } }
        function updateActionInstructions() { if (actionInstructionsElement) { if (!isReloaded && !isReloading) { actionInstructionsElement.textContent = "Hold R to reload"; } else if (isReloading) { actionInstructionsElement.textContent = "Reloading..."; } else { actionInstructionsElement.textContent = "E to shoot"; } } }
        function hideInitialInstructions() { if (!firstInputReceived && initialInstructionsElement) { firstInputReceived = true; initialInstructionsElement.classList.add('hidden'); setTimeout(() => { if (initialInstructionsElement && initialInstructionsElement.parentNode) { initialInstructionsElement.parentNode.removeChild(initialInstructionsElement); initialInstructionsElement = null; } }, 500); } }
        function updateScoreUI() {
             if (scoreP1Element && scoreP2Element) {
                  scoreP1Element.textContent = `${localPlayerId === 'p1' ? localUsername : remoteUsername}: ${localPlayerId === 'p1' ? localScore : remoteScore}`;
                  scoreP2Element.textContent = `${localPlayerId === 'p2' ? localUsername : remoteUsername}: ${localPlayerId === 'p2' ? localScore : remoteScore}`;
                  scoreP1Element.style.color = localPlayerId === 'p1' ? localColor : remoteColor;
                  scoreP2Element.style.color = localPlayerId === 'p2' ? localColor : remoteColor;
             }
        }

        // --- Game Logic Functions ---
        function handlePlayerDeath(playerId) {
             if (currentGameState !== GameState.GAME_PLAYING) return;
             console.log(`Player ${playerId} died!`);
             const winnerId = playerId === localPlayerId ? remotePlayerId : localPlayerId; const loserId = playerId;
             const winnerName = winnerId === localPlayerId ? localUsername : remoteUsername; const loserName = loserId === localPlayerId ? localUsername : remoteUsername; const winnerColor = winnerId === localPlayerId ? localColor : remoteColor;
             if (winnerId === localPlayerId) localScore++; else remoteScore++; updateScoreUI();
             showRoundOverMessage(winnerName, loserName, winnerColor); setGameState(GameState.ROUND_OVER);
             if (isHost) { sendData({ type: 'round_over_ack' }); setTimeout(startNextRoundOrCutscene, 3000); }
             const targetTank = playerId === localPlayerId ? localTank : remoteTank;
             const targetState = playerId === localPlayerId ? localTankState : remoteTankState;
             if (targetState) targetState.isAlive = false;
             if (targetTank) { createExplosion(targetTank.position); targetTank.visible = false; }
        }
        function startNextRoundOrCutscene() {
            roundOverMsgElement.classList.remove('active');
             const roundsNeeded = maxRounds === Infinity ? Infinity : Math.ceil(maxRounds / 2);
             if ((localScore >= roundsNeeded || remoteScore >= roundsNeeded) && maxRounds !== Infinity) {
                  setGameState(GameState.CUTSCENE_START);
             } else {
                  currentRound++; console.log(`Starting Round ${currentRound}`);
                  resetRound(); setGameState(GameState.GAME_PLAYING);
             }
        }
        function resetRound() {
             localTankState.health = maxPlayerHealth; localTankState.isAlive = true;
             remoteTankState.health = maxPlayerHealth; remoteTankState.isAlive = true;
             isReloaded = true; reloadProgress = 1.0; updateHealthBar(); updateReloadBar(); updateActionInstructions();
             const spawnPos1 = new THREE.Vector3(-100, 30, 0); const spawnRot1 = Math.PI / 2; const spawnPos2 = new THREE.Vector3(100, 30, 0); const spawnRot2 = -Math.PI / 2;
             if (isHost) { localTankState.position.copy(spawnPos1); localTankState.yaw = spawnRot1; remoteTankState.targetPosition.copy(spawnPos2); remoteTankState.targetYaw = spawnRot2; }
             else { localTankState.position.copy(spawnPos2); localTankState.yaw = spawnRot2; remoteTankState.targetPosition.copy(spawnPos1); remoteTankState.targetYaw = spawnRot1; }
             remoteTankState.position.copy(remoteTankState.targetPosition); remoteTankState.yaw = remoteTankState.targetYaw;
             if(localTank) localTank.visible = true; if(remoteTank) remoteTank.visible = true;
             for (const b of bullets) scene.remove(b); bullets.length = 0;
             for (const e of explosions) { if(e.userData.audio && e.userData.audio.isPlaying) e.userData.audio.stop(); scene.remove(e); } explosions.length = 0;
             for (const p of particles) scene.remove(p); particles.length = 0;
        }
        function showRoundOverMessage(winnerName, loserName, winnerColor) {
             const messages = [ `Looks like ${winnerName} is dominating!`, `And one for ${winnerName}!`, `Too bad for ${loserName}!`, `Ouch, ${loserName} needs to step it up!`, `Thats a brutal hit by ${winnerName}!`, `${winnerName} is on fire!`, `Better luck next time, ${loserName}!`, `${winnerName} with the clutch victory!`, `Is ${loserName} even trying?`, `${winnerName} just owned the battlefield!` ];
             roundOverMsgElement.textContent = messages[Math.floor(Math.random() * messages.length)];
             roundOverMsgElement.style.color = winnerColor;
        }
        function resetScoresAndStartGame() { localScore = 0; remoteScore = 0; currentRound = 1; updateScoreUI(); setGameState(GameState.GAME_LOADING); }

        // --- Refactored Animate Helpers ---
        function updateLocalTank(delta) {
            if (!localTankState.isAlive || !localTank || !ground) return; // Add ground check
            // Physics
            if (controlsEnabled) {
                if (moveLeft) playerAngularVelocity += playerTurnAcceleration * delta; if (moveRight) playerAngularVelocity -= playerTurnAcceleration * delta;
                if (moveForward) localTankState.velocity.z += playerAcceleration * delta; if (moveBackward) localTankState.velocity.z -= playerAcceleration * delta;
            }
            playerAngularVelocity = THREE.MathUtils.damp(playerAngularVelocity, 0, playerTurnDamping, delta); localTankState.velocity.z = THREE.MathUtils.damp(localTankState.velocity.z, 0, playerDamping, delta);
            localTankState.yaw += playerAngularVelocity * delta;
            // Collision & Movement
            yawQuaternion.setFromAxisAngle(upVector, localTankState.yaw); playerForward.set(0, 0, -1).applyQuaternion(yawQuaternion);
            if (currentGameState === GameState.GAME_PLAYING && collidables.length > 0) {
                 const collisionCheckDistance = 8;
                 if (localTankState.velocity.z > 0) { collisionRaycaster.set(localTankState.position, playerForward); const intersects = collisionRaycaster.intersectObjects(collidables, true); if (intersects.length > 0 && intersects[0].distance < collisionCheckDistance) localTankState.velocity.z = 0; }
                 if (localTankState.velocity.z < 0) { const backward = playerForward.clone().negate(); collisionRaycaster.set(localTankState.position, backward); const intersects = collisionRaycaster.intersectObjects(collidables, true); if (intersects.length > 0 && intersects[0].distance < collisionCheckDistance) localTankState.velocity.z = 0; }
            }
            localTankState.position.add(playerForward.clone().multiplyScalar(localTankState.velocity.z * delta));
            // Ground Clamp & Tilt
            rayOrigin.copy(localTankState.position).y += 10; raycaster.set(rayOrigin, upVector.clone().multiplyScalar(-1)); const groundIntersects = raycaster.intersectObject(ground);
            if (groundIntersects && groundIntersects.length > 0) { const intersect = groundIntersects[0]; localTankState.position.y = intersect.point.y + 1.0; groundNormal.copy(intersect.face.normal).applyQuaternion(ground.quaternion).normalize(); tiltQuaternion.setFromUnitVectors(upVector, groundNormal); finalQuaternion.copy(yawQuaternion).multiply(tiltQuaternion); localTank.quaternion.copy(finalQuaternion); }
            else { localTankState.position.y -= 1 * delta; }
            localTank.position.copy(localTankState.position);
            // Send State
            sendData({ type: 'state_update', state: { position: localTankState.position.toArray(), yaw: localTankState.yaw, headYaw: localTankState.headYaw, turretPitch: localTankState.turretPitch, health: localTankState.health } });
        }
        function updateRemoteTank(delta) {
            if (!remoteTankState.isAlive || !remoteTank || !ground) return;
            remoteTankState.position.lerp(remoteTankState.targetPosition, delta * 10.0);
            remoteTankState.yaw = THREE.MathUtils.lerp(remoteTankState.yaw, remoteTankState.targetYaw, delta * 10.0);
            // Ground Clamp & Tilt for Remote
            yawQuaternion.setFromAxisAngle(upVector, remoteTankState.yaw); rayOrigin.copy(remoteTankState.position).y += 10; raycaster.set(rayOrigin, upVector.clone().multiplyScalar(-1)); const groundIntersects = raycaster.intersectObject(ground);
            if (groundIntersects && groundIntersects.length > 0) { const intersect = groundIntersects[0]; remoteTankState.position.y = intersect.point.y + 1.0; groundNormal.copy(intersect.face.normal).applyQuaternion(ground.quaternion).normalize(); tiltQuaternion.setFromUnitVectors(upVector, groundNormal); finalQuaternion.copy(yawQuaternion).multiply(tiltQuaternion); remoteTank.quaternion.copy(finalQuaternion); }
            else { remoteTankState.position.y -= 1 * delta; }
            remoteTank.position.copy(remoteTankState.position);
            // Aim Interpolation
            remoteTankState.headYaw = THREE.MathUtils.lerp(remoteTankState.headYaw, remoteTankState.targetHeadYaw, delta * headTurnSpeed); remoteTankState.turretPitch = THREE.MathUtils.lerp(remoteTankState.turretPitch, remoteTankState.targetTurretPitch, delta * turretPitchSpeed);
            if (tankHeadPivotRemote) tankHeadPivotRemote.rotation.y = remoteTankState.headYaw; if (tankTurretPivotRemote) tankTurretPivotRemote.rotation.y = remoteTankState.turretPitch;
            remoteTank.visible = remoteTankState.isAlive;
        }
        function updateCamera(delta) {
            let targetFov = defaultFov; const activeTank = localTank; const activeTankState = localTankState;
            if (!activeTank || !tankTurretPivotLocal) return;
            if (isRegeneratingMap) { camera.position.lerp(regenCameraPos, delta * 2.0); camera.lookAt(regenCameraLookAt); }
            else if (isFollowingBullet) { followBulletTimer += delta; const followProgress = Math.min(followBulletTimer / followBulletDuration, 1.0); followBulletLookAt.copy(followBulletStartPos).add(followBulletDirection.clone().multiplyScalar(100)); camera.lookAt(followBulletLookAt); if (followProgress >= 1.0) isFollowingBullet = false; }
            else if (isPrecisionAiming) {
                 targetFov = THREE.MathUtils.mapLinear(precisionZoomLevel, 0, 1, precisionFovBase, precisionFovMin);
                 muzzleWorldPos.copy(muzzlePosition); tankTurretPivotLocal.localToWorld(muzzleWorldPos); precisionCamPos.copy(muzzleWorldPos);
                 muzzleDirection.set(0, 0, -1); tankTurretPivotLocal.getWorldQuaternion(muzzleWorldQuat); muzzleOffsetQuat.setFromEuler(muzzleRotation); muzzleWorldQuat.multiply(muzzleOffsetQuat); muzzleDirection.applyQuaternion(muzzleWorldQuat).normalize();
                 lookAtTarget.copy(precisionCamPos).add(muzzleDirection);
                 camera.position.lerp(precisionCamPos, delta * 10.0);
                 precisionCamQuat.copy(camera.quaternion); camera.lookAt(lookAtTarget); precisionCamTargetQuat.copy(camera.quaternion); camera.quaternion.copy(precisionCamQuat).slerp(precisionCamTargetQuat, delta * 10.0);
            }
            else {
                 lookAtTarget.copy(activeTankState.position).add(cameraLookAtOffset);
                 cameraOffset.set( cameraDistance * Math.sin(cameraYaw) * Math.cos(cameraPitch), cameraDistance * Math.sin(cameraPitch), cameraDistance * Math.cos(cameraYaw) * Math.cos(cameraPitch) );
                 thirdPersonCamPos.copy(lookAtTarget).add(cameraOffset);
                 if (camera.fov !== defaultFov || camera.position.distanceTo(thirdPersonCamPos) > 0.1) { camera.position.lerp(thirdPersonCamPos, delta * 10.0); precisionCamQuat.copy(camera.quaternion); camera.lookAt(lookAtTarget); precisionCamTargetQuat.copy(camera.quaternion); camera.quaternion.copy(precisionCamQuat).slerp(precisionCamTargetQuat, delta * 10.0); }
                 else { camera.position.copy(thirdPersonCamPos); camera.lookAt(lookAtTarget); }
            }
            if (Math.abs(camera.fov - targetFov) > 0.01) { camera.fov = THREE.MathUtils.lerp(camera.fov, targetFov, delta * 5.0); camera.updateProjectionMatrix(); }
        }
        function updateTankAim(delta) {
             // Local Aim
             if (tankHeadPivotLocal && tankTurretPivotLocal && localTankState.isAlive) {
                 let targetHeadYaw = localTankState.headYaw; let targetTurretPitch = localTankState.turretPitch;
                 if (!isAimLocked && !isPrecisionAiming) { targetHeadYaw = cameraYaw - localTankState.yaw; const normalizedMouseY = (mouseY - (window.innerHeight / 2)) / (window.innerHeight / 2); const mousePitch = -normalizedMouseY; const basePitch = THREE.MathUtils.mapLinear(cameraPitch, 0.1, 1.4, 0, -10 * (Math.PI / 180)); const mousePitchOffset = mousePitch * (30 * (Math.PI / 180)); targetTurretPitch = basePitch + mousePitchOffset; }
                 else if (isPrecisionAiming) { targetHeadYaw = cameraYaw - localTankState.yaw; targetTurretPitch = THREE.MathUtils.mapLinear(cameraPitch, cameraPitchMin, cameraPitchMax, 45 * (Math.PI / 180), -10 * (Math.PI / 180)); }
                 const maxPitchUp = 45 * (Math.PI / 180); const maxPitchDown = -10 * (Math.PI / 180); targetTurretPitch = THREE.MathUtils.clamp(targetTurretPitch, maxPitchDown, maxPitchUp);
                 if (isPrecisionAiming || isAimLocked) { localTankState.headYaw = targetHeadYaw; localTankState.turretPitch = targetTurretPitch; }
                 else { localTankState.headYaw = THREE.MathUtils.lerp(localTankState.headYaw, targetHeadYaw, delta * headTurnSpeed); localTankState.turretPitch = THREE.MathUtils.lerp(localTankState.turretPitch, targetTurretPitch, delta * turretPitchSpeed); }
                 tankHeadPivotLocal.rotation.y = localTankState.headYaw; tankTurretPivotLocal.rotation.y = localTankState.turretPitch;
             }
             // Remote Aim (Visual Only)
             if (tankHeadPivotRemote && tankTurretPivotRemote && remoteTankState.isAlive) { tankHeadPivotRemote.rotation.y = remoteTankState.headYaw; tankTurretPivotRemote.rotation.y = remoteTankState.turretPitch; }
        }
        function updateDebugVisuals(delta) {
            const showDebugVisuals = isDebugMode || (isPrecisionAiming && trajectoryLine);
            if(localTank?.userData.headPivotMarker) localTank.userData.headPivotMarker.visible = isDebugMode; // Use refs stored on tank
            if(localTank?.userData.turretPivotMarker) localTank.userData.turretPivotMarker.visible = isDebugMode;
            if(remoteTank?.userData.headPivotMarker) remoteTank.userData.headPivotMarker.visible = isDebugMode;
            if(remoteTank?.userData.turretPivotMarker) remoteTank.userData.turretPivotMarker.visible = isDebugMode;
            if(muzzleDebugArrow) muzzleDebugArrow.visible = isDebugMode;
            if(trajectoryLine) trajectoryLine.visible = showDebugVisuals;

            if (showDebugVisuals && tankTurretPivotLocal) { // Use local turret pivot
                 for (const obj of collidables) { if (obj.debugLine && localTank) { const positions = obj.debugLine.geometry.attributes.position; positions.setXYZ(0, localTankState.position.x, localTankState.position.y, localTankState.position.z); positions.setXYZ(1, obj.position.x, obj.position.y, obj.position.z); positions.needsUpdate = true; } }
                 // Pivot markers are positioned relative to their parents, no need to update position here if parent moves

                 muzzleWorldPos.copy(muzzlePosition); tankTurretPivotLocal.localToWorld(muzzleWorldPos); muzzleDirection.set(0, 0, -1); tankTurretPivotLocal.getWorldQuaternion(muzzleWorldQuat); muzzleOffsetQuat.setFromEuler(muzzleRotation); muzzleWorldQuat.multiply(muzzleOffsetQuat); muzzleDirection.applyQuaternion(muzzleWorldQuat).normalize();
                 if (muzzleDebugArrow && isDebugMode) { muzzleDebugArrow.position.copy(muzzleWorldPos); muzzleDebugArrow.setDirection(muzzleDirection); }
                 if (trajectoryLine) {
                      trajectoryPoints.length = 0; trajectoryPoints.push(muzzleWorldPos.x, muzzleWorldPos.y, muzzleWorldPos.z);
                      trajectoryVelocity.copy(muzzleDirection).multiplyScalar(bulletSpeed); const trajectoryPos = muzzleWorldPos.clone(); const simDelta = 1 / 60; const numSteps = 180;
                      for (let i = 1; i < numSteps; i++) { trajectoryVelocity.y -= bulletGravityStrength * simDelta; trajectoryPos.add(trajectoryVelocity.clone().multiplyScalar(simDelta)); trajectoryPoints.push(trajectoryPos.x, trajectoryPos.y, trajectoryPos.z); if (trajectoryPos.y < localTankState.position.y - 10) break; }
                      const positionAttribute = trajectoryLine.geometry.attributes.position; positionAttribute.set(trajectoryPoints); positionAttribute.needsUpdate = true; trajectoryLine.geometry.setDrawRange(0, trajectoryPoints.length / 3); trajectoryLine.computeLineDistances();
                 }
            }
        }
        function applyCameraShake(delta) { if (cameraShakeIntensity > 0.01) { shakeOffset.set( (Math.random() - 0.5) * cameraShakeIntensity, (Math.random() - 0.5) * cameraShakeIntensity, (Math.random() - 0.5) * cameraShakeIntensity ); camera.position.add(shakeOffset); cameraShakeIntensity = THREE.MathUtils.damp(cameraShakeIntensity, 0, 5.0, delta); } else { cameraShakeIntensity = 0; } }


        // --- Animate Loop ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            // Updates based on Game State
            switch (currentGameState) {
                 case GameState.MENU: case GameState.HOSTING_MODE_SELECT: case GameState.HOSTING_GET_ANSWER: case GameState.JOINING_GET_OFFER: case GameState.JOINING_SHARE_ANSWER: case GameState.CONNECTING: break; // No 3D
                 case GameState.GAME_LOADING: /* Maybe update loading text */ break;
                case GameState.GAME_PLAYING: case GameState.ROUND_OVER:
                    updateBullets(delta); updateExplosions(delta); updateParticles(delta);
                    if (isReloading) {
                        reloadProgress += delta / reloadTime;
                        if (reloadProgress >= 1.0) { reloadProgress = 1.0; isReloaded = true; isReloading = false; updateActionInstructions(); }
                        updateReloadBar();
                    }
                    if (localTank && remoteTank && ground) {
                         updateLocalTank(delta); updateRemoteTank(delta);
                         updateCamera(delta); updateTankAim(delta);
                         applyCameraShake(delta); updateDebugVisuals(delta);
                    }
                    break;
                 case GameState.CUTSCENE_START: cutsceneTimer += delta; if (localTank) { const targetPos = localTankState.position.clone().add(new THREE.Vector3(0, 5, 10)); camera.position.lerp(targetPos, delta * 1.0); lookAtTarget.copy(localTankState.position); camera.lookAt(lookAtTarget); } if (cutsceneTimer > 1.5) setGameState(GameState.CUTSCENE_SCORE); break;
                 case GameState.CUTSCENE_SCORE: cutsceneTimer += delta; const scoreAnimSpeed = 2.0; if (scoreRevealP1 < localScore) scoreRevealP1 = Math.min(localScore, scoreRevealP1 + scoreAnimSpeed * delta); if (scoreRevealP2 < remoteScore) scoreRevealP2 = Math.min(remoteScore, scoreRevealP2 + scoreAnimSpeed * delta); scoreRevealP1Span.textContent = Math.floor(scoreRevealP1); scoreRevealP2Span.textContent = Math.floor(scoreRevealP2); if (scoreRevealP1 >= localScore && scoreRevealP2 >= remoteScore) { if (localScore > remoteScore) { scoreRevealSeparatorSpan.textContent = ">"; scoreRevealP2Span.classList.add('loser-score'); scoreRevealP1Span.classList.remove('loser-score'); } else if (remoteScore > localScore) { scoreRevealSeparatorSpan.textContent = "<"; scoreRevealP1Span.classList.add('loser-score'); scoreRevealP2Span.classList.remove('loser-score'); } else { scoreRevealSeparatorSpan.textContent = "="; scoreRevealP1Span.classList.remove('loser-score'); scoreRevealP2Span.classList.remove('loser-score'); } scoreRevealP1Span.style.color = localColor; scoreRevealP2Span.style.color = remoteColor; if (cutsceneTimer > 4.0) setGameState(GameState.CUTSCENE_OUTCOME); } break;
                 case GameState.CUTSCENE_OUTCOME: cutsceneTimer += delta; if (localTank) { if (localScore > remoteScore) { localTankState.velocity.z = playerAcceleration * 0.5; updateLocalTank(delta); if(Math.abs(localTank.position.z) > 250 || Math.abs(localTank.position.x) > 250){ setGameState(GameState.CUTSCENE_END); } } else { localTank.visible = false; if (cutsceneTimer > 6.0) setGameState(GameState.CUTSCENE_END); } } else { if (cutsceneTimer > 6.0) setGameState(GameState.CUTSCENE_END); } applyCameraShake(delta); break;
                 case GameState.CUTSCENE_END: cutsceneTimer += delta; cinematicTopBar.classList.add('full'); cinematicBottomBar.classList.add('full'); if (cutsceneTimer > 9.0) { location.reload(); } break;
            }

            // Always Render if renderer exists
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
        }
    </script>
</body>
</html>

